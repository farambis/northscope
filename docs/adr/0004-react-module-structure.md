# ADR-0004: React Module Structure

## Status

Accepted

## Context

Fara-Scope is starting as a single dashboard page but will grow to include detail views, anomaly detection, data export, and more. Before building features, we need to agree on how to organize modules inside `src/` so the codebase stays navigable as it scales. The project uses Next.js 16 (App Router), React 19, TypeScript, shadcn/ui, and Tailwind CSS.

Without an explicit convention, React projects tend to drift into inconsistent patterns — shared logic gets duplicated, imports become circular, and new developers don't know where to put things.

## Decision

We organize `src/` into six top-level directories with clear responsibilities and a strict unidirectional dependency flow.

### Directory layout

```
src/
├── app/              # Next.js routes — pages and layouts only
├── components/       # React components, grouped by feature
│   └── ui/           # shadcn/ui primitives (generated, not hand-written)
├── lib/              # Pure utility functions (no React, no side effects)
├── data/             # Mock data and data-generation functions
├── hooks/            # Custom React hooks (when extracted)
└── types/            # TypeScript type definitions (no runtime code)
```

Feature folders are added under `components/` as needed (e.g. `components/dashboard/`, `components/kpi-detail/`).

### Rules

**1. Feature-based component folders**

Components are grouped by the feature they belong to, not by their technical role. Each feature folder contains all components, and their colocated tests, that belong to that feature.

A component that is used by more than one feature stays in the feature folder where it originated and is imported cross-feature. If it becomes truly generic (no domain logic), it moves to `components/ui/` or is installed via shadcn.

**2. `components/ui/` is reserved for shadcn primitives**

These files are generated by `npx shadcn add` and should not contain domain logic. Custom wrappers around shadcn components live in the feature folder that needs them.

**3. One concern per file in `lib/`**

Each file in `lib/` addresses a single concern (e.g. formatting, aggregation, diffing). Lib modules are pure functions — no React hooks, no component imports, no side effects. They may import from `types/` but not from `components/`, `data/`, or `app/`.

**4. One domain per file in `types/`**

Type files map to business domains (e.g. KPIs, trends, anomalies). They contain only TypeScript type definitions and string literal unions — no runtime code, no functions, no constants.

**5. `data/` holds static data and generators**

Mock data arrays and data-generation functions live here. Data modules may import from `types/` only. When the application connects to a real API, data-fetching logic will move to a `services/` or `api/` directory (a future ADR will address this).

**6. `hooks/` for extracted React hooks**

Custom hooks are created only when stateful logic is reused across two or more components. Until then, hooks remain inline in the component that uses them. This avoids premature abstraction.

**7. No barrel exports (index.ts files)**

All imports use explicit file paths: `import { KpiCard } from "@/components/dashboard/KpiCard"`. This makes dependencies grep-able, avoids circular import risks, and produces clear import statements that name both the module and the file.

### Dependency direction

Imports flow strictly downward. No layer may import from a layer above it.

```
app/  →  components/  →  lib/  →  types/
                ↓          ↓
              data/      (external packages)
```

- `app/` imports from `components/`, `data/`, `types/`
- `components/` imports from `components/ui/`, `lib/`, `types/`, `data/`
- `lib/` imports from `types/` and external packages only
- `types/` imports from other `types/` files only
- `data/` imports from `types/` only

Circular imports are not permitted. If two modules need to share logic, the shared part is extracted into `lib/` or `types/`.

### Naming conventions

| Category | Convention | Example |
|----------|-----------|---------|
| Components | PascalCase | `KpiCard.tsx` |
| Utilities | camelCase | `format.ts` |
| Hooks | camelCase, `use` prefix | `useKpiData.ts` |
| Types | camelCase | `kpi.ts` |
| Tests | Source name + `.test` | `KpiCard.test.tsx` |

### Server vs Client components

Components are Server Components by default. The `"use client"` directive is added only when the component uses browser APIs, React hooks (`useState`, `useEffect`, etc.), or event handlers. This is a per-component decision, not a per-folder convention — a feature folder may contain both server and client components.

## Alternatives Considered

| Alternative | Why not |
|-------------|---------|
| **Layer-based folders** (`components/cards/`, `components/charts/`, `components/layout/`) | Groups technically similar files that are functionally unrelated. Adding a feature requires touching many folders. Feature-based grouping keeps related files close together. |
| **Barrel exports** (index.ts per folder) | Introduces import indirection, complicates tree-shaking, and creates a common source of circular dependencies. Direct file imports are explicit and tooling-friendly. |
| **Monorepo / packages** (`packages/ui`, `packages/core`) | Overhead of package boundaries, separate build configs, and workspace tooling is not justified for a single-app project at this scale. Can be introduced if the project splits into multiple apps. |
| **Domain-Driven Design modules** (bounded contexts, aggregates) | DDD is designed for complex domain logic and multi-team codebases. Fara-Scope is a UI-focused dashboard with simple data flows — DDD would add ceremony without benefit. |
| **Colocation of types and data with components** (no separate `types/` or `data/` folder) | Works for small projects, but types and data will be shared across multiple feature folders. Centralizing them avoids duplication and makes the data model discoverable. |

## Consequences

- New features follow a predictable pattern: create a folder in `components/`, add types to `types/`, add utilities to `lib/` — developers know where things go
- Feature folders can grow independently without affecting other features
- The unidirectional dependency rule prevents circular imports and keeps the architecture flat
- Colocated tests mean deleting a feature folder removes all its code and tests in one step
- The structure will need to evolve if the application introduces server-side data fetching (API routes, server actions), authentication, or shared state management — each of these should be addressed in a dedicated ADR
